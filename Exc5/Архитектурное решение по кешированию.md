# Кеширование

## Анализ

Согласно условию задачи основные проблемы в плане скорости работы у сервиса MES. А именно: долгая загрузка первой страницы, которая содержит список заказов в работе по статусам. Вопрос должен решать введением системы кеширования. Хотя признаюсь, учитывая предполагаемый профиль нагрузки на сервис и БД, я бы сначала посмотрел что творится в БД, но, учитывая что у нас ещё нету метрик и мониторинга, а делать что-то нужно быстро, можно ввести кеширование

## Мотивация

Ввести можно обе разновидности кеширования, но решит проблемы с производительностью только серверная, клиентская может использоваться для оптимизации нагрузки на сеть и сервисы, а также ускорения отзывчивости клиента сервиса. При правильной реализации серверное кеширование позволит ускорить время загрузки данных по заказам. По описанию задачи у нас превалируют операции чтения, поэтому имеет смысл смотреть в сторону паттернов кеширования имеющих данную характеристику основной, т.е. Cache-Aside и Refresh-Ahead. Вторая подходит нам меньше потому что требует хорошего мониторинга из-за возможных ошибок обновления кеша. Итого мы выбираем Cache-Aside (в начале работы сервиса рекомендуется насильно прогреть кеш по всем актуальным заказам, чтобы предоставить удобоваримый QoS даже для самых первых пользователей). Возможен дальнейший переход на Refresh-Ahead, когда система чуть стабилизуется по сравнению со своим текущим состоянием. В плане записи можно использовать тактику аналогичную поведению Write-Behind + Transactional Outbox (или просто Write-Through)

## Предлагаемое решение

Предполагается что мы рассматриваем работу с состоянием заказа в объёме MES (поскольку Shop имеет собственное представление сущности заказ)

![Диаграмма](../docs/diagrams/out/order_sequence/Диаграмма%20последовательности%20для%20действий%20со%20статусом%20заказа.svg)

### Стратегия инвалидации кеша

В данном случае нам подойдёт программная инвалидация. Наш сервис владеет всеми нужными данными и актуальность кеша напрямую зависит от его действий. В такой ситуации будет логично использовать инвалидацию кеша в соответствии с логикой приложения. Это позволяет гибко, быстро и гранулировано инвалидировать данные в кеше

Единственная совсем плохо применимая стратегия инвалидации - временная, поскольку никакой привязки актуальности данных ко времени нет

Инвалидация по ключу также вполне применима, пусть она не столь гибка как программная, по предоставляет достаточную гранулярность обновления

Остальные стратегии инвалидации кеша имеют смысл только если рассматривать кеш заказов как индивидуальные небольшие объекты, а не монолитный кусок данных, иначе цена обновления слишком высока
